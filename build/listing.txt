ca65 V2.19 - Git c3d7a9008
Main file   : abn6502rom.s
Current file: abn6502rom.s

000000r 1               .feature string_escapes ; Allow c-style string escapes when using ca65
000000r 1               .feature org_per_seg
000000r 1               DEBUG = 0
000000r 1               PORTB = $6000
000000r 1               PORTA = $6001
000000r 1               DDRB = $6002
000000r 1               DDRA = $6003
000000r 1               T1CL = $6004
000000r 1               T1CH = $6005
000000r 1               T1LL = $6006
000000r 1               T1LH = $6007
000000r 1               T2CL = $6008
000000r 1               T2CH = $6009
000000r 1               SR1   = $600A
000000r 1               ACR  = $600B ; [7] PB.7 T1 OUT, [6] T1 mode , [5] T2, [4:2] Shift register control, [1] PB Latch enable, [2] PA Latch Enable
000000r 1               PCR  = $600C ; [7:5] CB2 Control, [4] CBl Control, [3:1] CA2 Control, [0] CAl Control
000000r 1               IFR  = $600D ; [7:0] IRQ Tl T2 CBl CB2 SR CA1 CA2
000000r 1               IER  = $600E ; [7:0] S/C Tl T2 CBl CB2 SR CA1 CA2
000000r 1               PORTANHS = $600F
000000r 1               CTRL = $5000
000000r 1               
000000r 1               TIMEOUT = 7998 ; Should be around 4ms
000000r 1               
000000r 1               kb_wptr = $0000
000000r 1               kb_rptr = $0001
000000r 1               kb_flags = $0002
000000r 1               kb_last = $0004
000000r 1               
000000r 1               RELEASE = %00000001
000000r 1               SHIFT   = %00000010
000000r 1               ECODE   = %00000100
000000r 1               CRSR    = %01000000
000000r 1               CRSRF   = %10000000
000000r 1               
000000r 1               kb_buffer = $0200  ; 256-byte kb buffer 0200-02ff
000000r 1               
000000r 1               ;Custom keyboard mappings
000000r 1               DN_ARR_KEY = $F3
000000r 1               UP_ARR_KEY = $F4
000000r 1               PGUP_KEY =   $F6
000000r 1               PGDN_KEY =   $F5
000000r 1               L_ARR_KEY = $F2
000000r 1               R_ARR_KEY = $F1
000000r 1               HOME_KEY = $F0
000000r 1               ESC_KEY  =  $1b
000000r 1               
000000r 1               CRSRT   = $1B
000000r 1               CRSRCHR = $1C
000000r 1               RF_ERR = $1D
000000r 1               ERRS = $1F
000000r 1               
000000r 1               
000000r 1               MILLIS = $40
000000r 1               MILLISH = $41
000000r 1               
000000r 1               HXH = $44
000000r 1               MONCNT = $46
000000r 1               
000000r 1               SLB =  $47 ; Size low byte
000000r 1               SHB = $48
000000r 1               SVP = $42 ; Save pointer
000000r 1               SVPH =$43
000000r 1               
000000r 1               TMP = $50;
000000r 1               TMP2 = $51;
000000r 1               CRSRPNT = $52
000000r 1               CRSRPNT2 = CRSRPNT+1
000000r 1               
000000r 1               SCREENSTARTH = $20
000000r 1               SCREENSTARTL = $4B
000000r 1               LINESTART = 11
000000r 1               NUMLINES = 30
000000r 1               
000000r 1               MONH = $59
000000r 1               MONL = $58
000000r 1               ABUF = $5A
000000r 1               ;to $61
000000r 1               
000000r 1               outb  = $56
000000r 1               inb = $57
000000r 1               
000000r 1               RF_STS = $68
000000r 1               ; CE = $69
000000r 1               MSGBUF = $90
000000r 1               ;+32bytes == To $AF
000000r 1               
000000r 1               uservia = PORTB
000000r 1               mosi  = %01000000
000000r 1               
000000r 1               .segment "RODATA"
000000r 1               ;.org $8000 ; Not strictly needed with CA65 but shows correct address in listing.txt
000000r 1               .list on ; Does this work?
000000r 1                 nmi:
000000r 1                 reset:
000000r 1  D8                     cld ; Because you never know
000001r 1               
000001r 1                         ;CLEAR RAM
000001r 1  78                     sei
000002r 1  A2 00                  ldx #$0
000004r 1                 clearram:
000004r 1  A9 00                  lda #0
000006r 1  95 00                  sta $00,x
000008r 1  E8                     inx
000009r 1  D0 F9                  bne clearram
00000Br 1               
00000Br 1                         ;Assumes x and A are 0 from above
00000Br 1                 clearstack:
00000Br 1  9D 00 01               sta $0100,x
00000Er 1  E8                     inx
00000Fr 1  D0 FA                  bne clearstack
000011r 1               
000011r 1               noclear: ;Soft reset point - BRK
000011r 1  A9 01                  lda #$01  ; CA1 positive active edge
000013r 1  8D 0C 60               sta PCR
000016r 1  8D 00 50               sta CTRL ; Enable video, bank 0
000019r 1  A9 C2                  lda #%11000010  ; Set CA1 + T1
00001Br 1  8D 0E 60               sta IER
00001Er 1  A9 58                  LDA #%01011000
000020r 1  8D 0B 60               STA ACR             ; T1 continuous, PB7 disabled, Shift Out Ã˜2
000023r 1                         ;cli       ; Enable interrupts Let's do this when KB is ready
000023r 1               
000023r 1  A9 3E                  LDA #<TIMEOUT
000025r 1  8D 04 60               STA T1CL            ; Set low byte of timer1 counter
000028r 1  A9 1F                  LDA #>TIMEOUT
00002Ar 1  8D 05 60               STA T1CH            ; Set high byte of timer1 counter
00002Dr 1               
00002Dr 1  20 rr rr               jsr clrscn
000030r 1               
000030r 1  A9 4B                  lda #SCREENSTARTL
000032r 1  85 52                  sta CRSRPNT
000034r 1  A9 20                  lda #SCREENSTARTH
000036r 1  85 53                  sta CRSRPNT2
000038r 1  A9 FF                  lda #$FF
00003Ar 1  8D 03 60               sta DDRA
00003Dr 1  AA                     tax
00003Er 1  9A                     txs
00003Fr 1               
00003Fr 1  A9 02                  lda #2
000041r 1  8D 00 60               sta PORTB ; Set SPI CS high
000044r 1  A9 57                  lda #%01010111 ; Port B DDR for SPI
000046r 1  8D 02 60               sta DDRB
000049r 1  A9 00                  lda #0
00004Br 1               
00004Br 1  8D 03 60               sta DDRA ; Port A all inputs for keyboard
00004Er 1  85 01                  sta kb_rptr ; Init keyboard pointers before enabling interrupts
000050r 1  85 00                  sta kb_wptr
000052r 1  85 1D                  sta RF_ERR ; Reset RF error
000054r 1  58                     cli
000055r 1               
000055r 1  A2 10                  ldx #$10 ; Read first tx addr byte = should be default, if not then no module connected
000057r 1  20 rr rr               jsr rw_reg
00005Ar 1  C9 E7                  cmp #$E7
00005Cr 1  F0 02                  beq welcome
00005Er 1  E6 1D                  inc RF_ERR ; No module, set RF_ERR
000060r 1               welcome:
000060r 1  20 C8 FF               jsr PRIMM
000063r 1  47 52 45 45  message:	.asciiz "GREETINGS PROFESSOR FALKEN.", "\n", "SHALL WE PLAY A GAME?", "\n"
000067r 1  54 49 4E 47  
00006Br 1  53 20 50 52  
000096r 1               
000096r 1               welcomedone:
000096r 1               
000096r 1  2C 0B 60               bit ACR
000099r 1  30 12                  bmi skiprf
00009Br 1  A5 1D                  lda RF_ERR
00009Dr 1  D0 0E                  bne skiprf
00009Fr 1  78                     sei
0000A0r 1  20 rr rr               jsr initrf24
0000A3r 1  58                     cli
0000A4r 1               
0000A4r 1               main:
0000A4r 1  A5 1D        lda RF_ERR
0000A6r 1  D0 05        bne skiprf
0000A8r 1  2C 0B 60     bit ACR ; If ACR.7 is set then we can't use SPI since MOSI is outputting TM1.
0000ABr 1  10 03        bpl rfstuff
0000ADr 1               skiprf:
0000ADr 1  4C rr rr     jmp nomsg
0000B0r 1               rfstuff:
0000B0r 1               ;jsr readrf24regs ; Debug - we can also just do an rf_nop to read rf24 status (RF_STS)
0000B0r 1               
0000B0r 1  20 rr rr     jsr rf_nop ; Not debug
0000B3r 1  58           cli
0000B4r 1               ;If msg received, put it in MSGBUF
0000B4r 1  24 68        bit RF_STS
0000B6r 1  70 09        bvs gtgm ; Check irq
0000B8r 1  A5 68        lda RF_STS
0000BAr 1  C9 0E        cmp #$0e ; Check if fifo empty
0000BCr 1  D0 03        bne gtgm
0000BEr 1  4C rr rr     jmp nomsg; No msg received
0000C1r 1               gtgm:
0000C1r 1  78           sei
0000C2r 1  20 rr rr     jsr getmessage
0000C5r 1               
0000C5r 1  A5 90        lda $90
0000C7r 1  D0 3A        bne datapacket  ; Check for control message
0000C9r 1  A5 91        lda $91
0000CBr 1  C9 31        cmp #$31 ; Trust but verify
0000CDr 1  F0 06        beq ctrlmsg
0000CFr 1  20 rr rr     jsr initrf24 ; Junk package. Reset radio.
0000D2r 1  4C rr rr     jmp nomsg
0000D5r 1               ctrlmsg:
0000D5r 1  A5 92        lda $92
0000D7r 1  85 D0        sta $d0 ; Data size low byte
0000D9r 1  A5 93        lda $93
0000DBr 1  85 D1        sta $d1 ; Data size high byte
0000DDr 1               
0000DDr 1  20 C8 FF       jsr PRIMM
0000E0r 1  52 65 63 65    .asciiz "Receiving $"
0000E4r 1  69 76 69 6E  
0000E8r 1  67 20 24 00  
0000ECr 1  A5 D1          lda $d1
0000EEr 1  20 rr rr       jsr printbyte
0000F1r 1  A5 D0          lda $d0
0000F3r 1  20 rr rr       jsr printbyte
0000F6r 1  20 C8 FF       jsr PRIMM
0000F9r 1  20 62 79 74    .asciiz " bytes. \n"
0000FDr 1  65 73 2E 20  
000101r 1  0A 00        
000103r 1               
000103r 1               datapacket:
000103r 1               
000103r 1               getmsg:
000103r 1  E6 D2        inc $d2
000105r 1  A5 90        lda $90
000107r 1  C9 01        cmp #1
000109r 1  D0 12        bne nextpacket ; Data package with ID > 1
00010Br 1  A5 D1        lda $d1 ; Size high byte
00010Dr 1  85 48        sta SHB
00010Fr 1  E6 48        inc SHB
000111r 1  A5 D0        lda $d0 ; Size low byte
000113r 1  85 47        sta SLB
000115r 1  A9 00        lda #0
000117r 1  85 42        sta SVP
000119r 1  A9 03        lda #3
00011Br 1  85 43        sta SVP+1 ; Save pointer starts at $0300
00011Dr 1               
00011Dr 1               nextpacket:
00011Dr 1  A2 02        ldx #2
00011Fr 1               fetchpacket:
00011Fr 1  B5 90        lda $90,x
000121r 1  A0 00        ldy #0
000123r 1  91 42        sta (SVP),y
000125r 1  E6 42        inc SVP
000127r 1  D0 02        bne nnhb
000129r 1  E6 43        inc SVP+1
00012Br 1               nnhb:
00012Br 1  C6 47        dec SLB
00012Dr 1  D0 04        bne movealong
00012Fr 1  C6 48        dec SHB
000131r 1  F0 32        beq txdone ; 0 bytes left - All done!
000133r 1               movealong:
000133r 1  C6 48        dec SHB
000135r 1  A5 48        lda SHB
000137r 1  20 rr rr     jsr printbyte
00013Ar 1  E6 48        inc SHB
00013Cr 1  A5 47        lda SLB
00013Er 1  20 rr rr     jsr printbyte
000141r 1  20 C8 FF     jsr PRIMM
000144r 1  20 62 79 74  .asciiz " bytes left(hex)"
000148r 1  65 73 20 6C  
00014Cr 1  65 66 74 28  
000155r 1  A5 52        lda CRSRPNT
000157r 1  29 C0        and #%11000000 ; keep only section bits
000159r 1  09 0B        ora #LINESTART ;
00015Br 1  85 52        sta CRSRPNT
00015Dr 1  E8           inx
00015Er 1  E0 20        cpx #32
000160r 1  D0 BD        bne fetchpacket
000162r 1  4C rr rr     jmp main
000165r 1               
000165r 1               txdone:
000165r 1  A9 03            lda #3
000167r 1  85 31            sta $31
000169r 1  A9 00            lda #0
00016Br 1  85 01            sta kb_rptr ; Reset the keyboard pointers here.
00016Dr 1  85 00            sta kb_wptr
00016Fr 1  85 30            sta $30
000171r 1  A5 52            lda CRSRPNT ; Let's return to beginning of the line
000173r 1  29 C0            and #%11000000 ; keep only section bits
000175r 1  09 0B            ora #LINESTART ;
000177r 1  85 52            sta CRSRPNT
000179r 1  A5 48            lda SHB
00017Br 1  20 rr rr         jsr printbyte
00017Er 1  A5 47            lda SLB
000180r 1  20 rr rr         jsr printbyte
000183r 1  20 C8 FF         jsr PRIMM
000186r 1  20 62 79 74      .asciiz " bytes left(hex)\n"
00018Ar 1  65 73 20 6C  
00018Er 1  65 66 74 28  
000198r 1  20 C8 FF         jsr PRIMM
00019Br 1  0A 44 61 74      .asciiz "\nData loaded into RAM at $0300. \nPress F5 or type \"run\" to start executing at $0300. \n"
00019Fr 1  61 20 6C 6F  
0001A3r 1  61 64 65 64  
0001F2r 1  20 rr rr         jsr rf_nop
0001F5r 1  58               cli
0001F6r 1               
0001F6r 1               nomsg:
0001F6r 1               
0001F6r 1  24 1B            bit CRSRT
0001F8r 1  30 09            bmi isneg
0001FAr 1  A5 02            lda kb_flags
0001FCr 1  29 7F            and #$7f
0001FEr 1  85 02            sta kb_flags ; Reset flip
000200r 1  38               sec
000201r 1  B0 1C            bcs skippedcursor ; BRA
000203r 1               
000203r 1                   isneg:
000203r 1  24 02            bit kb_flags ; Same as last?
000205r 1  10 02            bpl flip
000207r 1  30 16            bmi skippedcursor ; We already flipped
000209r 1               
000209r 1               flip:
000209r 1               
000209r 1  A5 02            lda kb_flags
00020Br 1  49 40            eor #CRSR
00020Dr 1  09 80            ora #CRSRF ; Set flip bit
00020Fr 1  85 02            sta kb_flags
000211r 1  24 02            bit kb_flags
000213r 1  70 06            bvs cursoroff
000215r 1                   cursoron:
000215r 1  A9 5F            lda #'_'
000217r 1  91 52            sta (CRSRPNT),y
000219r 1  D0 04            bne cursordone ; BRA
00021Br 1                   cursoroff:
00021Br 1  A5 1C            lda CRSRCHR
00021Dr 1  91 52            sta (CRSRPNT),y
00021Fr 1                   cursordone:
00021Fr 1                   skippedcursor:
00021Fr 1               
00021Fr 1               
00021Fr 1               .if DEBUG
00021Fr 1                   lda CRSRPNT ; Save cursor..
00021Fr 1                   sta $54
00021Fr 1                   pha
00021Fr 1                   lda CRSRPNT2
00021Fr 1                   sta $55
00021Fr 1                   pha
00021Fr 1                   LDA #$7c  ; Print timer in upper right corner of screen
00021Fr 1                   sta CRSRPNT
00021Fr 1                   lda #$27
00021Fr 1                   sta CRSRPNT2
00021Fr 1                   lda MILLISH
00021Fr 1                   jsr printbyte
00021Fr 1               
00021Fr 1                   LDA #$74 ; Debug ERRS and show cursor pointer next to timer on screen
00021Fr 1                   sta CRSRPNT
00021Fr 1                   lda #$27
00021Fr 1                   sta CRSRPNT2
00021Fr 1                   lda ERRS
00021Fr 1                   jsr printbyte
00021Fr 1                   inc CRSRPNT
00021Fr 1                   lda $55
00021Fr 1                   jsr printbyte
00021Fr 1                   lda $54
00021Fr 1                   jsr printbyte
00021Fr 1               
00021Fr 1                   pla
00021Fr 1                   sta CRSRPNT2
00021Fr 1                   pla
00021Fr 1                   sta CRSRPNT
00021Fr 1               .endif
00021Fr 1  78               sei
000220r 1  A5 01            lda kb_rptr
000222r 1  C5 00            cmp kb_wptr
000224r 1  58               cli
000225r 1  D0 03            bne key_pressed
000227r 1  4C rr rr         jmp main
00022Ar 1               
00022Ar 1               key_pressed:
00022Ar 1  A6 01              ldx kb_rptr
00022Cr 1  BD 00 02           lda kb_buffer, x
00022Fr 1  C9 0A              cmp #$0a           ; enter - go new line
000231r 1  F0 61              beq enter_pressed
000233r 1  C9 1B              cmp #$1b           ; escape - clear display
000235r 1  F0 5A              beq esc
000237r 1  C9 08              cmp #$08
000239r 1  F0 3B              beq back
00023Br 1  C9 FE              cmp #$FE  ;Scan code $05
00023Dr 1  F0 4F              beq f1
00023Fr 1  C9 FD              cmp #$FD
000241r 1  F0 48              beq f2
000243r 1  C9 FC              cmp #$FC
000245r 1  F0 41              beq f3
000247r 1  C9 FB              cmp #$FB
000249r 1  F0 3A              beq f4
00024Br 1  C9 FA              cmp #$FA
00024Dr 1  F0 33              beq f5
00024Fr 1  C9 F9              cmp #$F9
000251r 1  F0 2C              beq f6
000253r 1  C9 F8              cmp #$F8
000255r 1  F0 25              beq f7
000257r 1  C9 F7              cmp #$F7
000259r 1  F0 1E              beq f8
00025Br 1               
00025Br 1  C9 F2              cmp #L_ARR_KEY
00025Dr 1  F0 14              beq golrudarr
00025Fr 1  C9 F1              cmp #R_ARR_KEY
000261r 1  F0 10              beq golrudarr
000263r 1  C9 F4              cmp #UP_ARR_KEY
000265r 1  F0 0C              beq golrudarr
000267r 1  C9 F3              cmp #DN_ARR_KEY
000269r 1  F0 08              beq golrudarr
00026Br 1               
00026Br 1  20 rr rr           jsr printk
00026Er 1               printedkey:
00026Er 1  E6 01              inc kb_rptr
000270r 1               
000270r 1  4C rr rr           jmp main
000273r 1               
000273r 1               golrudarr:
000273r 1  4C rr rr           jmp lrudarr
000276r 1               
000276r 1               back:
000276r 1  4C rr rr           jmp backspace_pressed
000279r 1               f8:
000279r 1  4C rr rr           jmp f8_pressed
00027Cr 1               f7:
00027Cr 1  4C rr rr           jmp f7_pressed
00027Fr 1               f6:
00027Fr 1  4C rr rr           jmp f6_pressed
000282r 1               f5:
000282r 1  4C rr rr           jmp f5_pressed
000285r 1               f4:
000285r 1  4C rr rr           jmp f4_pressed
000288r 1               
000288r 1               f3:
000288r 1  4C rr rr           jmp f3_pressed
00028Br 1               f2:
00028Br 1  4C rr rr           jmp f2_pressed
00028Er 1               
00028Er 1               f1:
00028Er 1  4C rr rr           jmp f1_pressed
000291r 1               
000291r 1               esc:
000291r 1  4C rr rr           jmp esc_pressed
000294r 1               
000294r 1               enter_pressed:
000294r 1  A5 1C              lda CRSRCHR
000296r 1  91 52              sta (CRSRPNT),y
000298r 1  A2 00              ldx #0
00029Ar 1  BD 00 02           lda kb_buffer,x
00029Dr 1               parsecmd:
00029Dr 1  C9 72              cmp #'r'
00029Fr 1  F0 0F              beq read
0002A1r 1  C9 77              cmp #'w'
0002A3r 1  F0 50              beq write
0002A5r 1  C9 48              cmp #'H'
0002A7r 1  F0 0A              beq strangegame
0002A9r 1  C9 68              cmp #'h'
0002ABr 1  F0 06              beq strangegame
0002ADr 1  4C rr rr           jmp err
0002B0r 1               read:
0002B0r 1  4C rr rr           jmp jread
0002B3r 1               
0002B3r 1               strangegame:
0002B3r 1  20 C8 FF           jsr PRIMM
0002B6r 1  0A 41 20 53          .asciiz "\n", "A STRANGE GAME. THE ONLY WINNING ", "\n", "MOVE IS NOT TO PLAY.", "\n"
0002BAr 1  54 52 41 4E  
0002BEr 1  47 45 20 47  
0002EFr 1               wrotegtnw:
0002EFr 1  4C rr rr       jmp eom
0002F2r 1               
0002F2r 1               jerr:
0002F2r 1  4C rr rr       jmp err
0002F5r 1               
0002F5r 1               write:
0002F5r 1  A0 FF              ldy #$FF
0002F7r 1  E8                 inx
0002F8r 1  BD 00 02           lda kb_buffer,x
0002FBr 1  C9 72              cmp #'r'
0002FDr 1  D0 F3              bne jerr
0002FFr 1  A2 06              ldx #6
000301r 1  20 rr rr           jsr asctobyte
000304r 1  85 59              sta MONH ; Maybe we'll find a better place
000306r 1  E8                 inx
000307r 1  20 rr rr           jsr asctobyte
00030Ar 1  85 58              sta MONL
00030Cr 1               nextbyte:
00030Cr 1  E8                 inx
00030Dr 1  BD 00 02           lda kb_buffer,x
000310r 1  C9 20              cmp #' '
000312r 1  F0 F8              beq nextbyte
000314r 1  C5 2E              cmp '.'
000316r 1  F0 F4              beq nextbyte
000318r 1  C5 2C              cmp ','
00031Ar 1  F0 F0              beq nextbyte
00031Cr 1  C5 24              cmp '$'
00031Er 1  F0 EC              beq nextbyte
000320r 1  C9 0A              cmp #$0a
000322r 1  F0 09              beq exitwrite
000324r 1               
000324r 1               stbyte:
000324r 1  20 rr rr           jsr asctobyte
000327r 1  C8                 iny
000328r 1  91 58              sta (MONL),y
00032Ar 1  4C rr rr           jmp nextbyte
00032Dr 1               exitwrite:
00032Dr 1               ;      inc kb_rptr
00032Dr 1               ;      jmp newmon ; Previous behavior
00032Dr 1  20 C8 FF           jsr PRIMM
000330r 1  0A 57 72 6F        .asciiz "\nWrote "
000334r 1  74 65 20 00  
000338r 1  C8                 iny
000339r 1  98                 tya
00033Ar 1  20 rr rr           jsr printbyte
00033Dr 1  20 C8 FF           jsr PRIMM
000340r 1  20 62 79 74        .asciiz " bytes. Press F1 to enter monitor\n"
000344r 1  65 73 2E 20  
000348r 1  50 72 65 73  
000363r 1  4C rr rr           jmp eom
000366r 1               
000366r 1               
000366r 1               jread:
000366r 1  E8                 inx
000367r 1  BD 00 02           lda kb_buffer,x
00036Ar 1  C9 75              cmp #'u'
00036Cr 1  F0 6B              beq run
00036Er 1  C9 65              cmp #'e'
000370r 1  D0 41              bne err
000372r 1  A2 05              ldx #5
000374r 1  20 rr rr           jsr asctobyte
000377r 1  85 59              sta MONH
000379r 1  E8                 inx
00037Ar 1  20 rr rr           jsr asctobyte
00037Dr 1  85 58              sta MONL
00037Fr 1               ;      inc kb_rptr
00037Fr 1               ;      jmp newmon
00037Fr 1  A0 00              ldy #0
000381r 1  B1 58              lda (MONL),y
000383r 1  20 C8 FF           jsr PRIMM
000386r 1  0A 52 65 61        .asciiz "\nRead: "
00038Ar 1  64 3A 20 00  
00038Er 1  20 rr rr           jsr printbyte
000391r 1  20 C8 FF           jsr PRIMM
000394r 1  0A 50 72 65        .asciiz "\nPress F1 to enter monitor\n"
000398r 1  73 73 20 46  
00039Cr 1  31 20 74 6F  
0003B0r 1  4C rr rr           jmp eom
0003B3r 1               err:
0003B3r 1  A5 52              lda CRSRPNT
0003B5r 1  20 rr rr           jsr crnl
0003B8r 1  85 52              sta CRSRPNT
0003BAr 1  90 06              bcc clkbptr
0003BCr 1  E6 53              inc CRSRPNT2
0003BEr 1  B1 52              lda (CRSRPNT),y
0003C0r 1  85 1C              sta CRSRCHR
0003C2r 1               clkbptr:
0003C2r 1                     ; Clear keyboard pointers if this is the end of message
0003C2r 1  E6 01              inc kb_rptr
0003C4r 1  78                 sei
0003C5r 1  A5 01              lda kb_rptr
0003C7r 1  C5 00              cmp kb_wptr
0003C9r 1  58                 cli
0003CAr 1  D0 0A              bne notdone
0003CCr 1               eom:
0003CCr 1  B1 52              lda (CRSRPNT),y ; Save new char under cursor ; Here or in err:?
0003CEr 1  85 1C              sta CRSRCHR
0003D0r 1  A9 00              lda #0
0003D2r 1  85 01              sta kb_rptr
0003D4r 1  85 00              sta kb_wptr
0003D6r 1                   notdone:
0003D6r 1  4C rr rr           jmp main
0003D9r 1               
0003D9r 1               run:
0003D9r 1  A9 00              lda #0
0003DBr 1  85 01              sta kb_rptr
0003DDr 1  85 00              sta kb_wptr
0003DFr 1  6C 30 00           jmp ($0030)
0003E2r 1               
0003E2r 1               esc_pressed:
0003E2r 1  20 rr rr           jsr clrscn
0003E5r 1  A9 4B              lda #SCREENSTARTL
0003E7r 1  85 52              sta CRSRPNT
0003E9r 1  A9 20              lda #SCREENSTARTH
0003EBr 1  85 53              sta CRSRPNT2
0003EDr 1  4C rr rr           jmp clkbptr
0003F0r 1               
0003F0r 1               backspace_pressed:
0003F0r 1  A0 00                ldy #0
0003F2r 1  A5 1C                lda CRSRCHR
0003F4r 1  91 52                sta (CRSRPNT),y
0003F6r 1               normcrsr:
0003F6r 1  C6 52                dec CRSRPNT
0003F8r 1  A5 52                lda CRSRPNT
0003FAr 1  C9 FF                cmp #255
0003FCr 1  D0 02                bne notunder
0003FEr 1  C6 53                dec CRSRPNT2
000400r 1                       notunder:
000400r 1  A9 20                lda #' '
000402r 1  91 52                sta (CRSRPNT),y
000404r 1  C6 01                dec kb_rptr
000406r 1  C6 00                dec kb_wptr
000408r 1  C6 00                dec kb_wptr
00040Ar 1  4C rr rr             jmp main
00040Dr 1               
00040Dr 1               f1_pressed:
00040Dr 1  A9 00                lda #0
00040Fr 1  85 01                sta kb_rptr
000411r 1  85 00                sta kb_wptr
000413r 1  20 rr rr             jsr clrscn
000416r 1  4C rr rr             jmp monmon
000419r 1               
000419r 1               f2_pressed:
000419r 1               
000419r 1  4C rr rr             jmp eom
00041Cr 1               
00041Cr 1               f3_pressed:
00041Cr 1               
00041Cr 1  4C rr rr             jmp eom
00041Fr 1               
00041Fr 1               f4_pressed:
00041Fr 1  20 rr rr             jsr getmessage
000422r 1  20 C8 FF             jsr PRIMM
000425r 1  47 6F 74 20          .asciiz "Got message!"
000429r 1  6D 65 73 73  
00042Dr 1  61 67 65 21  
000432r 1  20 rr rr             jsr newline
000435r 1  4C rr rr             jmp eom
000438r 1               
000438r 1               f5_pressed:
000438r 1  20 rr rr             jsr rf_nop
00043Br 1  4C rr rr             jmp run
00043Er 1               
00043Er 1               f6_pressed:
00043Er 1  20 rr rr             jsr readrf24regs
000441r 1  20 C8 FF             jsr PRIMM
000444r 1  52 65 61 64          .asciiz "Read RF24 configuration!"
000448r 1  20 52 46 32  
00044Cr 1  34 20 63 6F  
00045Dr 1  20 rr rr             jsr newline
000460r 1  4C rr rr             jmp eom
000463r 1               
000463r 1               f7_pressed:
000463r 1  20 rr rr             jsr initrf24
000466r 1  4C rr rr             jmp eom
000469r 1               
000469r 1               f8_pressed:
000469r 1  4C rr rr               jmp reset
00046Cr 1               
00046Cr 1                       newmon:
00046Cr 1  20 rr rr                 jsr clrscn
00046Fr 1                       monmon:
00046Fr 1  A9 1D                    lda #29
000471r 1  85 46                    sta MONCNT
000473r 1  A5 59                    lda MONH
000475r 1  48                       pha
000476r 1  A5 58                    lda MONL
000478r 1  48                       pha
000479r 1  20 rr rr                 jsr mon
00047Cr 1  68                       pla
00047Dr 1  85 58                    sta MONL
00047Fr 1  68                       pla
000480r 1  85 59                    sta MONH
000482r 1               
000482r 1  78                       sei
000483r 1  A5 01                    lda kb_rptr
000485r 1  C5 00                    cmp kb_wptr
000487r 1  58                       cli
000488r 1  F0 E5                    beq monmon
00048Ar 1  A6 01                    ldx kb_rptr
00048Cr 1  E6 01                    inc kb_rptr
00048Er 1  BD 00 02                 lda kb_buffer, x
000491r 1  C9 1B                    cmp #ESC_KEY           ; escape - exit
000493r 1  F0 4B                    beq exitmon
000495r 1  C9 F6                    cmp #PGUP_KEY
000497r 1  F0 39                    beq monpgup
000499r 1  C9 F5                    cmp #PGDN_KEY
00049Br 1  F0 27                    beq monpgdn
00049Dr 1  C9 F4                    cmp #UP_ARR_KEY
00049Fr 1  F0 15                    beq monup
0004A1r 1  C9 F3                    cmp #DN_ARR_KEY
0004A3r 1  F0 03                    beq mondn
0004A5r 1               
0004A5r 1                           ; Let's loop here until keypress
0004A5r 1  4C rr rr                 jmp monmon ; No data - restart monitor
0004A8r 1               
0004A8r 1               mondn:      ; Arrow keys invert the natural direction because pressing down naturally means you want to see another line
0004A8r 1  18                       clc
0004A9r 1  A5 58                    lda MONL
0004ABr 1  69 08                    adc #$08
0004ADr 1  85 58                    sta MONL
0004AFr 1  90 BE                    bcc monmon
0004B1r 1  E6 59                    inc MONH
0004B3r 1  4C rr rr                 jmp monmon
0004B6r 1               
0004B6r 1               monup:      ; Pressing up means you want to see a line higher up == lower
0004B6r 1  38                       sec
0004B7r 1  A5 58                    lda MONL
0004B9r 1  E9 08                    sbc #$08
0004BBr 1  85 58                    sta MONL
0004BDr 1  B0 B0                    bcs monmon
0004BFr 1  C6 59                    dec MONH
0004C1r 1  4C rr rr                 jmp monmon
0004C4r 1               
0004C4r 1               
0004C4r 1               monpgdn:
0004C4r 1  18                       clc
0004C5r 1  A5 58                    lda MONL
0004C7r 1  69 D8                    adc #$D8
0004C9r 1  85 58                    sta MONL
0004CBr 1  90 A2                    bcc monmon
0004CDr 1  E6 59                    inc MONH
0004CFr 1  4C rr rr                 jmp monmon
0004D2r 1               
0004D2r 1               monpgup:
0004D2r 1  38                       sec
0004D3r 1  A5 58                    lda MONL
0004D5r 1  E9 D8                    sbc #$D8
0004D7r 1  85 58                    sta MONL
0004D9r 1  B0 94                    bcs monmon
0004DBr 1  C6 59                    dec MONH
0004DDr 1  4C rr rr                 jmp monmon
0004E0r 1               
0004E0r 1                       exitmon:
0004E0r 1  20 rr rr                 jsr clrscn ; Clear screen on monitor exit
0004E3r 1  A9 4B                    lda #SCREENSTARTL
0004E5r 1  85 52                    sta CRSRPNT
0004E7r 1  A9 20                    lda #SCREENSTARTH
0004E9r 1  85 53                    sta CRSRPNT2
0004EBr 1  4C rr rr                 jmp eom
0004EEr 1                       ;    lda #0
0004EEr 1                       ;    sta MILLISH
0004EEr 1               
0004EEr 1               asctohex:
0004EEr 1  C9 60                      cmp #$60
0004F0r 1  90 02                      bcc caps
0004F2r 1  E9 21                      sbc #$21
0004F4r 1               caps:
0004F4r 1  E9 2F                      sbc #'0'-1
0004F6r 1  C9 0A                      cmp #10
0004F8r 1  90 02                      bcc nothex
0004FAr 1  E9 07                      sbc #7
0004FCr 1               nothex:
0004FCr 1  60                   rts
0004FDr 1               
0004FDr 1               clrscn:
0004FDr 1  A9 00            lda #0
0004FFr 1  85 52            sta CRSRPNT
000501r 1  A9 20            lda #$20 ; Clear before screen to after screen
000503r 1  85 53            sta CRSRPNT2
000505r 1  A0 00            ldy #0
000507r 1  98               tya
000508r 1  A2 09            ldx #9
00050Ar 1                   clrloop:
00050Ar 1  91 52            sta (CRSRPNT),y
00050Cr 1  C8               iny
00050Dr 1  D0 FB            bne clrloop
00050Fr 1  E6 53            inc CRSRPNT2  ; increasing HI-byte of the clearing address.
000511r 1  CA               dex
000512r 1  D0 F6            bne clrloop
000514r 1  60               rts
000515r 1               
000515r 1               crnl: ; Carriage return new line - needs cursor pointer in A
000515r 1  29 C0            and #%11000000 ; keep only section bits
000517r 1  09 0B            ora #LINESTART ;
000519r 1  18               clc
00051Ar 1  69 40            adc #$40 ; CR
00051Cr 1  60               rts
00051Dr 1               
00051Dr 1               newline:
00051Dr 1  A5 52            lda CRSRPNT
00051Fr 1  20 rr rr         jsr crnl
000522r 1  85 52            sta CRSRPNT
000524r 1  29 E0            and #$E0 ; If msn is 0 then ++section
000526r 1  D0 02            bne newlinedone
000528r 1  E6 53            inc CRSRPNT2
00052Ar 1               newlinedone:
00052Ar 1  60               rts
00052Br 1               
00052Br 1               
00052Br 1               hextoa:
00052Br 1               ; wozmon-style
00052Br 1               ;    and #%00001111  ; Mask LSD for hex print.
00052Br 1               ; Already masked when we get here.
00052Br 1  09 30            ora #'0'        ; Add '0'.
00052Dr 1  C9 3A            cmp #'9'+1      ; Is it a decimal digit?
00052Fr 1  90 02            bcc ascr        ; Yes, output it.
000531r 1  69 06            adc #$06        ; Add offset for letter.
000533r 1               ascr:
000533r 1  60               rts
000534r 1               
000534r 1               
000534r 1               bytetoa: ;This SR puts LSB in A and MSB in HXH - as ascii using hextoa.
000534r 1  48               pha
000535r 1  4A               lsr
000536r 1  4A               lsr
000537r 1  4A               lsr
000538r 1  4A               lsr
000539r 1  18               clc
00053Ar 1  20 rr rr         jsr hextoa
00053Dr 1  85 44            sta HXH
00053Fr 1  68               pla
000540r 1  29 0F            and #$0F
000542r 1  20 rr rr         jsr hextoa
000545r 1  60               rts
000546r 1               
000546r 1               asctobyte: ; Reads two hex characters from keyboard buffer, x indexed, and returns a byte in A
000546r 1  BD 00 02         lda kb_buffer,x ; MSD
000549r 1  20 rr rr         jsr asctohex
00054Cr 1  0A               asl a
00054Dr 1  0A               asl a
00054Er 1  0A               asl a
00054Fr 1  0A               asl a
000550r 1  85 50            sta TMP
000552r 1  E8               inx
000553r 1  BD 00 02         lda kb_buffer,x ; LSD
000556r 1  20 rr rr         jsr asctohex
000559r 1  05 50            ora TMP
00055Br 1                   ; Return value in A
00055Br 1  60               rts
00055Cr 1               
00055Cr 1               mon:
00055Cr 1               ; Print line starting address
00055Cr 1               ; Print 8 ascii hex bytes separated by ' '
00055Cr 1               ; Print same 8 bytes as ASCII
00055Cr 1               ;newline
00055Cr 1               ;Let's start by resetting start pos
00055Cr 1  A9 20            lda #SCREENSTARTH ; If we are, then reset to top of screen
00055Er 1  85 53            sta CRSRPNT2
000560r 1  A9 4B            lda #SCREENSTARTL
000562r 1  85 52            sta CRSRPNT
000564r 1               nextline:
000564r 1  A2 08            ldx #8
000566r 1  A9 24            lda #'$'
000568r 1  20 rr rr         jsr printa
00056Br 1  A5 59            lda MONH
00056Dr 1  20 rr rr         jsr printbyte
000570r 1  A5 58            lda MONL
000572r 1  20 rr rr         jsr printbyte
000575r 1  A9 3A            lda #':'
000577r 1  20 rr rr         jsr printa
00057Ar 1  A9 20            lda #' '
00057Cr 1  20 rr rr         jsr printa
00057Fr 1  A0 00            ldy #0
000581r 1               nexthex:
000581r 1  B1 58            lda (MONL),y
000583r 1  95 5A            sta ABUF,x
000585r 1  20 rr rr         jsr printbyte
000588r 1  E6 52            inc CRSRPNT ; Make a space
00058Ar 1  E6 58            inc MONL
00058Cr 1  D0 02            bne notof
00058Er 1  E6 59            inc MONH
000590r 1               notof:
000590r 1  CA               dex
000591r 1  D0 EE            bne nexthex
000593r 1                   ; Print ascii
000593r 1  A2 08            ldx #8
000595r 1               printabuf:
000595r 1  B5 5A            lda ABUF,x
000597r 1  20 rr rr         jsr printa
00059Ar 1  CA               dex
00059Br 1  D0 F8            bne printabuf
00059Dr 1                   ; Get ready for a new line
00059Dr 1  A5 52            lda CRSRPNT
00059Fr 1  20 rr rr         jsr crnl ; Carriage Return New Line
0005A2r 1  85 52            sta CRSRPNT
0005A4r 1  29 E0            and #$E0 ; If msn is 0 then ++section
0005A6r 1  D0 02            bne gonext
0005A8r 1  E6 53            inc CRSRPNT2
0005AAr 1               gonext:
0005AAr 1  C6 46            dec MONCNT
0005ACr 1  D0 B6            bne nextline ; Was this the last line? No, nextline.
0005AEr 1  60               rts
0005AFr 1               
0005AFr 1               printbyte:
0005AFr 1  20 rr rr         jsr bytetoa
0005B2r 1  48               pha
0005B3r 1  A5 44            lda HXH
0005B5r 1  20 rr rr         jsr printa
0005B8r 1  68               pla
0005B9r 1  20 rr rr         jsr printa
0005BCr 1  60               rts
0005BDr 1               
0005BDr 1               printa:
0005BDr 1  85 51            sta TMP2 ; save A
0005BFr 1  98               TYA			; copy Y
0005C0r 1  48               PHA  			; save Y
0005C1r 1  8A               TXA			; copy X
0005C2r 1  48               PHA  			; save X
0005C3r 1  A0 00            ldy #0
0005C5r 1  A5 51            lda TMP2
0005C7r 1               
0005C7r 1  C9 0A            cmp #$0A ; Do we need this?
0005C9r 1  F0 0D            beq printnewline
0005CBr 1               
0005CBr 1  91 52            sta (CRSRPNT),y
0005CDr 1  E6 52            inc CRSRPNT
0005CFr 1  D0 02            bne printeda
0005D1r 1  E6 53            inc CRSRPNT2
0005D3r 1               printeda:
0005D3r 1  68               PLA			; pull value
0005D4r 1  AA               TAX  			; restore X
0005D5r 1  68               PLA			; pull value
0005D6r 1  A8               TAY  			; restore Y
0005D7r 1  60               rts
0005D8r 1               printnewline:
0005D8r 1  20 rr rr         jsr newline
0005DBr 1  4C rr rr         jmp printeda
0005DEr 1               
0005DEr 1               lrudarr:
0005DEr 1               ;    bit MILLIS
0005DEr 1               ;    bpl correctchr Not worth testing...
0005DEr 1  48               pha
0005DFr 1  A0 00            ldy #0
0005E1r 1  A5 1C            lda CRSRCHR     ; Make sure we leave the character in the position and not the cursor.
0005E3r 1  91 52            sta (CRSRPNT),y
0005E5r 1               correctchr:
0005E5r 1  68               pla
0005E6r 1  C9 F1            cmp #R_ARR_KEY
0005E8r 1  F0 27            beq rarr
0005EAr 1  C9 F4            cmp #UP_ARR_KEY
0005ECr 1  F0 37            beq uparr
0005EEr 1  C9 F3            cmp #DN_ARR_KEY
0005F0r 1  F0 40            beq dnarr
0005F2r 1               larr:
0005F2r 1  C6 52            dec CRSRPNT ; Move cursor left
0005F4r 1  A5 52            lda CRSRPNT
0005F6r 1  C9 FF            cmp #255
0005F8r 1  D0 02            bne checkline
0005FAr 1  C6 53            dec CRSRPNT2
0005FCr 1               checkline:
0005FCr 1  29 3F            and #%00111111
0005FEr 1  C9 0B            cmp #LINESTART
000600r 1  B0 3E            bcs checkedarrows
000602r 1  A5 52            lda CRSRPNT
000604r 1  38               sec
000605r 1  E9 40            sbc #$40
000607r 1  09 3E            ora #$3E
000609r 1  85 52            sta CRSRPNT
00060Br 1  B0 33            bcs checkedarrows
00060Dr 1  C6 53            dec CRSRPNT2
00060Fr 1  90 2F            bcc checkedarrows ; BRA
000611r 1               rarr:
000611r 1  E6 52            inc CRSRPNT
000613r 1  A5 52            lda CRSRPNT
000615r 1  29 3F            and #$3F   ; Discard MS bits since we only care about current line
000617r 1  C9 3F            cmp #$3f
000619r 1  90 25            bcc checkedarrows ; A < 62 == Not Front porch
00061Br 1  20 rr rr         jsr newline
00061Er 1  09 0B            ora #LINESTART
000620r 1  85 52            sta CRSRPNT
000622r 1  4C rr rr         jmp checkedarrows
000625r 1               uparr:
000625r 1  A5 52            lda CRSRPNT
000627r 1  38               sec
000628r 1  E9 40            sbc #$40
00062Ar 1  85 52            sta CRSRPNT
00062Cr 1  B0 12            bcs checkedarrows
00062Er 1  C6 53            dec CRSRPNT2
000630r 1  90 0E            bcc checkedarrows ; BRA
000632r 1               dnarr:
000632r 1  A5 52            lda CRSRPNT
000634r 1  18               clc
000635r 1  69 40            adc #$40
000637r 1  85 52            sta CRSRPNT
000639r 1  90 05            bcc checkedarrows
00063Br 1  E6 53            inc CRSRPNT2
00063Dr 1  4C rr rr         jmp checkedarrows
000640r 1               checkedarrows:
000640r 1  20 rr rr     jsr checkbottom
000643r 1  B1 52        lda (CRSRPNT),y ; Save new char under cursor
000645r 1  85 1C        sta CRSRCHR
000647r 1  A5 02        lda kb_flags
000649r 1  09 40        ora #CRSR
00064Br 1  85 02        sta kb_flags
00064Dr 1  A9 5F        lda #'_'
00064Fr 1  91 52        sta (CRSRPNT),y
000651r 1  4C rr rr     jmp printedkey
000654r 1               
000654r 1               printk:
000654r 1  48                 pha
000655r 1               checkl: ; This is user input, so we have to make sure we don't hit VGA blanking by mistake
000655r 1  A5 52            lda CRSRPNT
000657r 1  29 3F            and #$3F   ; Discard MS bits since we only care about current line
000659r 1  C9 3F            cmp #$3F
00065Br 1  90 03            bcc chs ; A < 62 == Not Front porch
00065Dr 1  20 rr rr         jsr newline
000660r 1               chs:
000660r 1  C9 0B            cmp #LINESTART
000662r 1  B0 04            bcs chs2
000664r 1  05 52            ora CRSRPNT
000666r 1  85 52            sta CRSRPNT
000668r 1               chs2:
000668r 1  20 rr rr         jsr checkbottom
00066Br 1               rpa:
00066Br 1  68               pla
00066Cr 1  20 rr rr         jsr printa
00066Fr 1  60               rts
000670r 1               
000670r 1               
000670r 1               checkbottom:
000670r 1  A5 53            lda CRSRPNT2 ; Check if we're off screen
000672r 1  C9 20            cmp #$20
000674r 1  90 0A            bcc resetcursor ; Off screen
000676r 1  C9 27            cmp #$27
000678r 1  90 0E            bcc checkedbottom ; if we're not
00067Ar 1  A5 52        lda CRSRPNT ; Check LSB as well if we're above $2700
00067Cr 1  C9 80        cmp #$80
00067Er 1  90 08        bcc checkedbottom
000680r 1               resetcursor:
000680r 1  A9 20        lda #SCREENSTARTH ; If we are, then reset to top of screen ; Or start scrolling?
000682r 1  85 53        sta CRSRPNT2
000684r 1  A9 4B        lda #SCREENSTARTL
000686r 1  85 52        sta CRSRPNT
000688r 1               checkedbottom:
000688r 1  60               rts
000689r 1               
000689r 1                 ; IRQ vector points here ; Thanks to Ben Eater for a very useful PS2->Ascii interface
000689r 1                 ;IFR is IRQ Tl T2 CBl CB2 SR CA1 CA2
000689r 1               irq:
000689r 1  48             pha
00068Ar 1               ;  lda #%00100000 ; We need T2 to fire super fast, so we check it first.
00068Ar 1               ;  and IFR
00068Ar 1               ;  bne t2_irq
00068Ar 1               
00068Ar 1               ;Alt approach
00068Ar 1               ; lda IER
00068Ar 1               ; and IFR ; We only care about active IRQ's
00068Ar 1               ; asl ; IRQ in C
00068Ar 1               ; asl ; T1 flag in C
00068Ar 1               ; bcs t1_irq
00068Ar 1               ; asl ; T2
00068Ar 1               ; bcs t2_irq
00068Ar 1               ; asl ; CB1
00068Ar 1               ; asl ; CB2
00068Ar 1               ; asl ; SR
00068Ar 1               ; asl ; CA1
00068Ar 1               ; bcs keyboard_interrupt
00068Ar 1               ; asl ; CA2
00068Ar 1               
00068Ar 1  2C 0D 60       bit IFR ; T1 as fast as possible
00068Dr 1  70 3D          bvs t1_irq
00068Fr 1               
00068Fr 1  8A             txa
000690r 1  48             pha
000691r 1  BA             tsx
000692r 1  BD 03 01       lda $0103,x ; Pull status register off stack and check break flag
000695r 1  29 10          and #$10
000697r 1  D0 0A          bne hitbrk
000699r 1               
000699r 1  AD 0D 60       lda IFR
00069Cr 1  29 02          and #2
00069Er 1  D0 12          bne keyboard_interrupt
0006A0r 1  E6 1F          inc ERRS ;Should never end up here...
0006A2r 1  40             rti
0006A3r 1               
0006A3r 1               hitbrk:
0006A3r 1                 ; jmp reset
0006A3r 1  E6 08          inc $08
0006A5r 1  A9 rr          lda #<main
0006A7r 1  9D 04 01       sta $104,x ; Return to main instead of breakpoint
0006AAr 1  A9 rr          lda #>main
0006ACr 1  9D 05 01       sta $105,x
0006AFr 1  4C rr rr     jmp exit
0006B2r 1               
0006B2r 1                 keyboard_interrupt:
0006B2r 1  A5 02            lda kb_flags
0006B4r 1  29 01            and #RELEASE   ; check if we're releasing a key
0006B6r 1  F0 38            beq read_key   ; otherwise, read the key
0006B8r 1               
0006B8r 1  A5 02            lda kb_flags
0006BAr 1  49 01            eor #RELEASE   ; flip the releasing bit
0006BCr 1  85 02            sta kb_flags
0006BEr 1  AD 01 60         lda PORTA      ; read key value that's being released
0006C1r 1  C9 12            cmp #$12       ; left shift
0006C3r 1  F0 1F            beq shift_up
0006C5r 1  C9 59            cmp #$59       ; right shift
0006C7r 1  F0 1B            beq shift_up
0006C9r 1  4C rr rr         jmp exit
0006CCr 1               
0006CCr 1                   t1_irq:
0006CCr 1  2C 04 60             bit T1CL ; Clear irq
0006CFr 1               
0006CFr 1                   gmillis:
0006CFr 1  E6 1B                inc CRSRT
0006D1r 1  E6 1B                inc CRSRT
0006D3r 1  E6 40                inc MILLIS
0006D5r 1  D0 02                bne t1_irq_exit
0006D7r 1  E6 41                inc MILLIS+1
0006D9r 1                   t1_irq_exit:
0006D9r 1  68                   pla
0006DAr 1  40                   rti
0006DBr 1               
0006DBr 1               
0006DBr 1               
0006DBr 1               ;        t2_irq:
0006DBr 1               ;        lda #%00010000
0006DBr 1               ;        eor PORTB
0006DBr 1               ;        sta PORTB
0006DBr 1               ;        lda #0
0006DBr 1               ;        sta T2CH ; pla + rti should be enough time for IRQ line to go high again before leaving IRQ - at 2 mhz anyway
0006DBr 1               ;        pla
0006DBr 1               ;        rti
0006DBr 1               
0006DBr 1                 ekey_up:
0006DBr 1  A5 02          lda kb_flags
0006DDr 1  29 FB          and #%11111011 ; Turn off ecode
0006DFr 1  85 02          sta kb_flags
0006E1r 1  4C rr rr       jmp exit
0006E4r 1               
0006E4r 1                 shift_up:
0006E4r 1  A5 02            lda kb_flags
0006E6r 1  49 02            eor #SHIFT  ; flip the shift bit
0006E8r 1  85 02            sta kb_flags
0006EAr 1  4C rr rr         jmp exit
0006EDr 1               
0006EDr 1                   break:
0006EDr 1  4C rr rr         jmp noclear
0006F0r 1               
0006F0r 1                 read_key:
0006F0r 1  AD 01 60         lda PORTA
0006F3r 1  C9 77            cmp #$77 ; Either numlock or pause/break - we reset without clearing ram
0006F5r 1  F0 F6            beq break
0006F7r 1  C9 F0            cmp #$f0        ; if releasing a key
0006F9r 1  F0 4C            beq key_release ; set the releasing bit
0006FBr 1  C9 12            cmp #$12        ; left shift
0006FDr 1  F0 3F            beq shift_down
0006FFr 1  C9 59            cmp #$59        ; right shift
000701r 1  F0 3B            beq shift_down
000703r 1  C9 E0            cmp #$E0
000705r 1  F0 16            beq ekey_down
000707r 1               
000707r 1  AA               tax
000708r 1  A5 02            lda kb_flags
00070Ar 1  29 04            and #ECODE
00070Cr 1  D0 1A            bne ecode_key
00070Er 1  A5 02            lda kb_flags
000710r 1  29 02            and #SHIFT
000712r 1  D0 1D            bne shifted_key
000714r 1               
000714r 1  8A               txa
000715r 1  85 04            sta kb_last
000717r 1  BD rr rr         lda keymap, x   ; map to character code
00071Ar 1  4C rr rr         jmp push_key
00071Dr 1               
00071Dr 1                   ekey_down:
00071Dr 1  85 04            sta kb_last
00071Fr 1  A5 02            lda kb_flags
000721r 1  09 04            ora #ECODE
000723r 1  85 02            sta kb_flags
000725r 1  4C rr rr         jmp exit
000728r 1               
000728r 1                   ecode_key:
000728r 1  8A               txa
000729r 1  85 04            sta kb_last
00072Br 1  BD rr rr         lda keymap_ecode,x
00072Er 1  4C rr rr         jmp push_key
000731r 1               
000731r 1                 shifted_key:
000731r 1  BD rr rr         lda keymap_shifted, x   ; map to character code
000734r 1               
000734r 1                 push_key:
000734r 1  A6 00            ldx kb_wptr
000736r 1  9D 00 02         sta kb_buffer, x
000739r 1  E6 00            inc kb_wptr
00073Br 1  4C rr rr         jmp exit
00073Er 1               
00073Er 1                 shift_down:
00073Er 1  A5 02            lda kb_flags
000740r 1  09 02            ora #SHIFT
000742r 1  85 02            sta kb_flags
000744r 1  4C rr rr         jmp exit
000747r 1               
000747r 1                 key_release:
000747r 1  A5 02            lda kb_flags
000749r 1  09 01            ora #RELEASE
00074Br 1  85 02            sta kb_flags
00074Dr 1  A5 04            lda kb_last
00074Fr 1  C9 E0            cmp #$e0
000751r 1  D0 03            bne exit
000753r 1  4C rr rr         jmp ekey_up
000756r 1               
000756r 1                 exit:
000756r 1  68               pla
000757r 1  AA               tax
000758r 1  68               pla
000759r 1  40               rti
00075Ar 1               
00075Ar 1               
00075Ar 1               ; Thanks to Ben Eater for a very useful PS2->Ascii interface
00075Ar 1                   keymap:
00075Ar 1  3F 3F 3F FA        .byte "???",$FA,$FC,$FE,$FD,"???",$F7,$F9,$FB," `?" ; 00-0F
00075Er 1  FC FE FD 3F  
000762r 1  3F 3F F7 F9  
00076Ar 1                     ;F1, F2, F3,F4, F5, F6, F7, F8 key bound to $FE, $FD, $FC, $FB, $FA, $F9, $F8, $F7 for no particular reason
00076Ar 1  3F 3F 3F 3F        .byte "?????q1???zsaw2?" ; 10-1F
00076Er 1  3F 71 31 3F  
000772r 1  3F 3F 7A 73  
00077Ar 1  3F 63 78 64        .byte "?cxde43?? vftr5?" ; 20-2F
00077Er 1  65 34 33 3F  
000782r 1  3F 20 76 66  
00078Ar 1  3F 6E 62 68        .byte "?nbhgy6???mju78?" ; 30-3F
00078Er 1  67 79 36 3F  
000792r 1  3F 3F 6D 6A  
00079Ar 1  3F 2C 6B 69        .byte "?,kio09??./l;p-?" ; 40-4F
00079Er 1  6F 30 39 3F  
0007A2r 1  3F 2E 2F 6C  
0007AAr 1  3F 3F 27 3F        .byte "??\'?[=????",$0a,"]?\\??" ; 50-5F
0007AEr 1  5B 3D 3F 3F  
0007B2r 1  3F 3F 0A 5D  
0007BAr 1  3F 3F 3F 3F        .byte "??????",$08,"??1?47???" ; 60-6F
0007BEr 1  3F 3F 08 3F  
0007C2r 1  3F 31 3F 34  
0007CAr 1  30 2E 32 35        .byte "0.2568",ESC_KEY,"??+3-*9??" ; 70-7F
0007CEr 1  36 38 1B 3F  
0007D2r 1  3F 2B 33 2D  
0007DAr 1  3F 3F 3F F8        .byte "???",$F8,"????????????" ; 80-8F $F8 = F7 key
0007DEr 1  3F 3F 3F 3F  
0007E2r 1  3F 3F 3F 3F  
0007EAr 1  3F 3F 3F 3F        .byte "????????????????" ; 90-9F
0007EEr 1  3F 3F 3F 3F  
0007F2r 1  3F 3F 3F 3F  
0007FAr 1  3F 3F 3F 3F        .byte "????????????????" ; A0-AF
0007FEr 1  3F 3F 3F 3F  
000802r 1  3F 3F 3F 3F  
00080Ar 1  3F 3F 3F 3F        .byte "????????????????" ; B0-BF
00080Er 1  3F 3F 3F 3F  
000812r 1  3F 3F 3F 3F  
00081Ar 1  3F 3F 3F 3F        .byte "????????????????" ; C0-CF
00081Er 1  3F 3F 3F 3F  
000822r 1  3F 3F 3F 3F  
00082Ar 1  3F 3F 3F 3F        .byte "????????????????" ; D0-DF
00082Er 1  3F 3F 3F 3F  
000832r 1  3F 3F 3F 3F  
00083Ar 1  3F 3F 3F 3F        .byte "????????????????" ; E0-EF
00083Er 1  3F 3F 3F 3F  
000842r 1  3F 3F 3F 3F  
00084Ar 1  3F 3F 3F 3F        .byte "????????????????" ; F0-FF
00084Er 1  3F 3F 3F 3F  
000852r 1  3F 3F 3F 3F  
00085Ar 1                   keymap_shifted:
00085Ar 1  3F 3F 3F 3F        .byte "????????????? ~?" ; 00-0F
00085Er 1  3F 3F 3F 3F  
000862r 1  3F 3F 3F 3F  
00086Ar 1  3F 3F 3F 3F        .byte "?????Q!???ZSAW@?" ; 10-1F
00086Er 1  3F 51 21 3F  
000872r 1  3F 3F 5A 53  
00087Ar 1  3F 43 58 44        .byte "?CXDE#$?? VFTR%?" ; 20-2F
00087Er 1  45 23 24 3F  
000882r 1  3F 20 56 46  
00088Ar 1  3F 4E 42 48        .byte "?NBHGY^???MJU&*?" ; 30-3F
00088Er 1  47 59 5E 3F  
000892r 1  3F 3F 4D 4A  
00089Ar 1  3F 3C 4B 49        .byte "?<KIO)(??>?L:P_?" ; 40-4F
00089Er 1  4F 29 28 3F  
0008A2r 1  3F 3E 3F 4C  
0008AAr 1  3F 3F 22 3F        .byte "??\"?{+?????}?|??" ; 50-5F
0008AEr 1  7B 2B 3F 3F  
0008B2r 1  3F 3F 3F 7D  
0008BAr 1  3F 3F 3F 3F        .byte "?????????1?47???" ; 60-6F
0008BEr 1  3F 3F 3F 3F  
0008C2r 1  3F 31 3F 34  
0008CAr 1  30 2E 32 35        .byte "0.2568???+3-*9??" ; 70-7F
0008CEr 1  36 38 3F 3F  
0008D2r 1  3F 2B 33 2D  
0008DAr 1  3F 3F 3F F8        .byte "???",$F8,"????????????" ; 80-8F $F8 = F7 key
0008DEr 1  3F 3F 3F 3F  
0008E2r 1  3F 3F 3F 3F  
0008EAr 1  3F 3F 3F 3F        .byte "????????????????" ; 90-9F
0008EEr 1  3F 3F 3F 3F  
0008F2r 1  3F 3F 3F 3F  
0008FAr 1  3F 3F 3F 3F        .byte "????????????????" ; A0-AF
0008FEr 1  3F 3F 3F 3F  
000902r 1  3F 3F 3F 3F  
00090Ar 1  3F 3F 3F 3F        .byte "????????????????" ; B0-BF
00090Er 1  3F 3F 3F 3F  
000912r 1  3F 3F 3F 3F  
00091Ar 1  3F 3F 3F 3F        .byte "????????????????" ; C0-CF
00091Er 1  3F 3F 3F 3F  
000922r 1  3F 3F 3F 3F  
00092Ar 1  3F 3F 3F 3F        .byte "????????????????" ; D0-DF
00092Er 1  3F 3F 3F 3F  
000932r 1  3F 3F 3F 3F  
00093Ar 1  3F 3F 3F 3F        .byte "????????????????" ; E0-EF
00093Er 1  3F 3F 3F 3F  
000942r 1  3F 3F 3F 3F  
00094Ar 1  3F 3F 3F 3F        .byte "????????????????" ; F0-FF
00094Er 1  3F 3F 3F 3F  
000952r 1  3F 3F 3F 3F  
00095Ar 1                     keymap_ecode:
00095Ar 1  30 30 30 30          .byte "0000000000000000" ; 00-0F
00095Er 1  30 30 30 30  
000962r 1  30 30 30 30  
00096Ar 1  30 30 30 30          .byte "0000000000000000" ; 10-1F
00096Er 1  30 30 30 30  
000972r 1  30 30 30 30  
00097Ar 1  30 30 30 30          .byte "0000000000000000" ; 20-2F
00097Er 1  30 30 30 30  
000982r 1  30 30 30 30  
00098Ar 1  30 30 30 30          .byte "0000000000000000" ; 30-3F
00098Er 1  30 30 30 30  
000992r 1  30 30 30 30  
00099Ar 1  30 30 30 30          .byte "0000000000000000" ; 40-4F
00099Er 1  30 30 30 30  
0009A2r 1  30 30 30 30  
0009AAr 1  30 30 30 30          .byte "0000000000000000" ; 50-5F
0009AEr 1  30 30 30 30  
0009B2r 1  30 30 30 30  
0009BAr 1  30 31 32 33          .byte "0123456789A",L_ARR_KEY, HOME_KEY, "DEF" ; 60-6F
0009BEr 1  34 35 36 37  
0009C2r 1  38 39 41 F2  
0009CAr 1  30 31 F3 33          .byte "01",DN_ARR_KEY,"3",R_ARR_KEY, UP_ARR_KEY, "6789",PGDN_KEY,"BC",PGUP_KEY,"EF" ; 70-7F $F6 = PGUP(7D), $F5 = PGDOWN(7A), $F4 = UP Arr.(75), Down arr.(72) = $F3
0009CEr 1  F1 F4 36 37  
0009D2r 1  38 39 F5 42  
0009DAr 1  30 30 30 30          .byte "0000000000000000" ; 80-8F $F8 = F7 key
0009DEr 1  30 30 30 30  
0009E2r 1  30 30 30 30  
0009EAr 1  3F 3F 3F 3F          .byte "????????????????" ; 90-9F
0009EEr 1  3F 3F 3F 3F  
0009F2r 1  3F 3F 3F 3F  
0009FAr 1  3F 3F 3F 3F          .byte "????????????????" ; A0-AF
0009FEr 1  3F 3F 3F 3F  
000A02r 1  3F 3F 3F 3F  
000A0Ar 1  3F 3F 3F 3F          .byte "????????????????" ; B0-BF
000A0Er 1  3F 3F 3F 3F  
000A12r 1  3F 3F 3F 3F  
000A1Ar 1  3F 3F 3F 3F          .byte "????????????????" ; C0-CF
000A1Er 1  3F 3F 3F 3F  
000A22r 1  3F 3F 3F 3F  
000A2Ar 1  3F 3F 3F 3F          .byte "????????????????" ; D0-DF
000A2Er 1  3F 3F 3F 3F  
000A32r 1  3F 3F 3F 3F  
000A3Ar 1  3F 3F 3F 3F          .byte "????????????????" ; E0-EF
000A3Er 1  3F 3F 3F 3F  
000A42r 1  3F 3F 3F 3F  
000A4Ar 1  3F 3F 3F 3F          .byte "????????????????" ; F0-FF
000A4Er 1  3F 3F 3F 3F  
000A52r 1  3F 3F 3F 3F  
000A5Ar 1               
000A5Ar 1               
000A5Ar 1                   spibyte:
000A5Ar 1                         ;SR borrowed from http://www.cyberspice.org.uk/blog/2009/08/25/bit-banging-spi-in-6502-assembler/
000A5Ar 1                         ;I think GW used this way too?
000A5Ar 1                         ;Bit 7 â€“ MISO (Input data from the slave to the computer) ; We can swap these by doing bvc spibyte2 instead of bpl spibyte2 and fixing DDRB - we should prefer PB7 to be an output and PB6 an input because of T1 and T2 hw features(T1 out to PB7 and T2 in to PB6)
000A5Ar 1                         ;Bit 6 â€“ MOSI (Output data from the computer to the slave)
000A5Ar 1                         ;Bit 1 â€“ SCS (Output slave chip select)
000A5Ar 1                         ;Bit 0 â€“ SCLK (Output SPI clock)
000A5Ar 1  85 56                              sta outb
000A5Cr 1  AD 00 60                           lda PORTB
000A5Fr 1  29 3C                              and #%00111100
000A61r 1                                     ; ora CE - No longer needed when we save all bits
000A61r 1  85 1E                              sta $1E
000A63r 1  8A                                 TXA
000A64r 1  48                                 PHA
000A65r 1  98                                 TYA
000A66r 1  48                                 PHA
000A67r 1               
000A67r 1  A0 00                              ldy #0
000A69r 1  84 57                              sty inb
000A6Br 1  A2 08                              ldx #8
000A6Dr 1                   spibytelp:
000A6Dr 1  98                                 tya		; (2) set A to 0
000A6Er 1  06 56                              asl outb	; (5) shift MSB in to carry
000A70r 1  90 02                              bcc spibyte1	; (2)
000A72r 1  09 40                              ora #mosi	; (2) set MOSI if MSB set
000A74r 1                   spibyte1:
000A74r 1  05 1E                              ora $1E ; Debug - set preserved port B bits
000A76r 1  8D 00 60                           sta uservia	; (4) output (MOSI, SCS low, SCLK low)
000A79r 1  98                                 tya		; (2) set A to 0 (Do it here for delay reasons)
000A7Ar 1  EE 00 60                           inc uservia	; (6) toggle clock high (SCLK is bit 0)
000A7Dr 1  18                                 clc		; (2) clear C (Not affected by bit)
000A7Er 1  2C 00 60                           bit uservia	; (4) copy MISO (bit 7) in to N (and MOSI in to V)
000A81r 1  10 01                              bpl spibyte2	; (2) bvc if miso bit 6, bpl if miso bit 7
000A83r 1  38                                 sec		; (2) set C if MISO bit is set (i.e. N) / Or V for miso on bit 6
000A84r 1                   spibyte2:
000A84r 1  26 57                              rol inb		; (5) copy C (i.e. MISO bit) in to bit 0 of result
000A86r 1  CE 00 60                           dec uservia	; (6) toggle clock low (SCLK is bit 0)
000A89r 1  CA                                 dex		; (2) next bit
000A8Ar 1  D0 E1                              bne spibytelp	; (2) loop
000A8Cr 1               
000A8Cr 1  68                                 PLA
000A8Dr 1  A8                                 TAY
000A8Er 1  68                                 PLA
000A8Fr 1  AA                                 TAX
000A90r 1               
000A90r 1  A5 57                              lda inb		; get result
000A92r 1  60                                 rts
000A93r 1               
000A93r 1                   rf_nop:
000A93r 1  AD 00 60                   lda PORTB
000A96r 1  29 FD                      and #%11111101 ; Set CS Low
000A98r 1  8D 00 60                   sta PORTB
000A9Br 1  A9 FF                      lda #$FF
000A9Dr 1  20 rr rr                   jsr spibyte
000AA0r 1  85 68                      sta RF_STS
000AA2r 1  AD 00 60                   lda PORTB
000AA5r 1  09 02                      ora #2 ; Set CS high
000AA7r 1  8D 00 60                   sta PORTB
000AAAr 1  60                         rts
000AABr 1               
000AABr 1                         ;rw_reg takes command in x and data in A. Returns data in A.
000AABr 1                   rw_reg:
000AABr 1  48                         pha
000AACr 1  AD 00 60                   lda PORTB
000AAFr 1  29 FD                      and #%11111101 ; Set CS Low
000AB1r 1  8D 00 60                   sta PORTB
000AB4r 1               
000AB4r 1  8A                         txa
000AB5r 1  20 rr rr                   jsr spibyte
000AB8r 1  85 68                      sta RF_STS
000ABAr 1               
000ABAr 1  68                         pla
000ABBr 1  20 rr rr                   jsr spibyte
000ABEr 1                             ; A has return value
000ABEr 1  48                         pha
000ABFr 1               
000ABFr 1  AD 00 60                   lda PORTB
000AC2r 1  09 02                      ora #2 ; Set CS high
000AC4r 1  8D 00 60                   sta PORTB
000AC7r 1               
000AC7r 1  68                         pla ; A has return value
000AC8r 1  60                         rts
000AC9r 1               
000AC9r 1               
000AC9r 1                   initrf24:
000AC9r 1  A2 E2                      ldx #$E2 ; Flush RX
000ACBr 1  A9 00                      lda #0
000ACDr 1  20 rr rr                   jsr rw_reg
000AD0r 1               
000AD0r 1  A2 27                      ldx #$27 ; Clear RX_DR
000AD2r 1  A9 40                      lda #$40
000AD4r 1  20 rr rr                   jsr rw_reg
000AD7r 1               
000AD7r 1  A2 3D                      ldx #$3D ; Set FEATURE register
000AD9r 1  A9 04                      lda #4
000ADBr 1  20 rr rr                   jsr rw_reg
000ADEr 1               
000ADEr 1  A2 3C                      ldx #$3C ; Set DYNDP register
000AE0r 1  A9 3F                      lda #$3F
000AE2r 1  20 rr rr                   jsr rw_reg
000AE5r 1               
000AE5r 1  A2 20                      ldx #$20 ; Power up, RX
000AE7r 1  A9 0F                      lda #$0F
000AE9r 1  20 rr rr                   jsr rw_reg
000AECr 1               
000AECr 1  AD 00 60                   lda PORTB ; Set CE high
000AEFr 1  09 04                      ora #4 ; CE is PB.2
000AF1r 1  8D 00 60                   sta PORTB
000AF4r 1  60                         rts
000AF5r 1               
000AF5r 1                   readrf24regs:
000AF5r 1  A2 1F                          ldx #31
000AF7r 1                   readrf24:
000AF7r 1  A9 00                          lda #0 ; Let's read first byte of all registers
000AF9r 1  20 rr rr                       jsr rw_reg
000AFCr 1  95 70                          sta $70,x
000AFEr 1  CA                             dex
000AFFr 1  10 F6                          bpl readrf24
000B01r 1  60                             rts
000B02r 1               
000B02r 1                   getmessage:
000B02r 1                   ; Here we read the msg
000B02r 1  A2 60            ldx #$60 ; Get top of RX fifo length - R_RX_PL_WID
000B04r 1  A9 00            lda #0
000B06r 1  20 rr rr         jsr rw_reg
000B09r 1  85 81            sta $81 ; Overwrite P0 payload length location in mem
000B0Br 1               
000B0Br 1  A0 00           ldy #0
000B0Dr 1  AD 00 60        lda PORTB
000B10r 1  29 FD           and #%11111101 ; Set CS Low
000B12r 1  8D 00 60        sta PORTB
000B15r 1                  readpayload:
000B15r 1  A9 61           lda #$61
000B17r 1  20 rr rr        jsr spibyte
000B1Ar 1  85 68           sta RF_STS
000B1Cr 1                  bytes:
000B1Cr 1  20 rr rr        jsr spibyte
000B1Fr 1  99 90 00        sta $90, y ;
000B22r 1  C8              iny
000B23r 1  C4 81           cpy $81
000B25r 1  D0 F5           bne bytes
000B27r 1  AD 00 60        lda PORTB
000B2Ar 1  09 02           ora #2 ; Set CS high
000B2Cr 1  8D 00 60        sta PORTB
000B2Fr 1               
000B2Fr 1  A2 27           ldx #$27 ; Clear RX_DR
000B31r 1  A9 40           lda #$40
000B33r 1  20 rr rr        jsr rw_reg
000B36r 1  60              rts
000B37r 1               
000B37r 1               
000B37r 1               ; Inline printing routine from http://6502.org/source/io/primm.htm
000B37r 1               .segment "PRIMM"
000000r 1               .org $ffc8
00FFC8  1                  PRIMM:
00FFC8  1  48              	PHA     		; save A
00FFC9  1  98              	TYA			; copy Y
00FFCA  1  48              	PHA  			; save Y
00FFCB  1  8A              	TXA			; copy X
00FFCC  1  48              	PHA  			; save X
00FFCD  1  BA              	TSX			; get stack pointer
00FFCE  1  BD 04 01        	LDA $0104,X		; get return address low byte (+4 to
00FFD1  1                  				;   correct pointer)
00FFD1  1  85 BC           	STA $BC			; save in page zero
00FFD3  1  BD 05 01        	LDA $0105,X		; get return address high byte (+5 to
00FFD6  1                  				;   correct pointer)
00FFD6  1  85 BD           	STA $BD			; save in page zero
00FFD8  1  A0 01           	LDY #$01		; set index (+1 to allow for return
00FFDA  1                  				;   address offset)
00FFDA  1                  PRIM2:
00FFDA  1  B1 BC           	LDA ($BC),Y		; get byte from string
00FFDC  1  F0 06           	BEQ PRIM3		; exit if null (end of text)
00FFDE  1               
00FFDE  1  20 rr rr        	JSR printk		; else display character
00FFE1  1  C8              	INY			; increment index
00FFE2  1  D0 F6           	BNE PRIM2		; loop (exit if 256th character)
00FFE4  1               
00FFE4  1                  PRIM3:
00FFE4  1  98              	TYA			; copy index
00FFE5  1  18              	CLC			; clear carry
00FFE6  1  65 BC           	ADC $BC			; add string pointer low byte to index
00FFE8  1  9D 04 01        	STA $0104,X		; put on stack as return address low byte
00FFEB  1                  				; (+4 to correct pointer, X is unchanged)
00FFEB  1  A9 00           	LDA #$00		; clear A
00FFED  1  65 BD           	ADC $BD		; add string pointer high byte
00FFEF  1  9D 05 01        	STA $0105,X		; put on stack as return address high byte
00FFF2  1                  				; (+5 to correct pointer, X is unchanged)
00FFF2  1  68              	PLA			; pull value
00FFF3  1  AA              	TAX  			; restore X
00FFF4  1  68              	PLA			; pull value
00FFF5  1  A8              	TAY  			; restore Y
00FFF6  1  68              	PLA  			; restore A
00FFF7  1  60              	RTS
00FFF8  1               
00FFF8  1               
00FFF8  1               .segment "VECTORS"
000000r 1               .ORG $fffa
00FFFA  1  rr rr rr rr  .word nmi,reset,irq
00FFFE  1  rr rr        
010000  1               .reloc
010000  1               
